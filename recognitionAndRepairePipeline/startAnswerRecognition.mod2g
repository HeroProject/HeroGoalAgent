use '../dialogflow' as knowledge.
use '../script' as knowledge.
use '../dialogflow' as actionspec.

module startAnswerRecognition(T, S) {

	if bel(currentAttempt(CurrentAttempt))
		then {
			if bel(currentInputModality(speech))
				then {
					% Start listening (with timeout by starting timer) and set waitingForAnswer flag.
					% when events have been completed (and we're not already waiting for an answer).
					% the first attempt has a different default waiting time than the subsequent attempts.
					if bel(CurrentAttempt == 1, keyListValues(T, S, [context, maxAnswerTimeFirst], [Context, MAX_AT]))
						then insert(waitingForAnswer) + starttimer(S, MAX_AT, MAX_AT) + startListening(Context).
					
					% answer time for second (and more; depends on maxAnswerAttempt) speech attempts.
					if bel(CurrentAttempt > 1, keyListValues(T, S, [context, maxAnswerTimeSecond], [Context, MAX_AT]))
						then insert(waitingForAnswer) + starttimer(S, MAX_AT, MAX_AT) + startListening(Context).
				}
			
			if bel(currentInputModality(touch))
				then {
					% Start timer for question state with touch response and set waitingForAnswer flag.
					% when events have been completed (and we're not already waiting for an answer).
					if bel(keyListValues(T, S, [type, maxAnswerTimeTouch], [yesno, MAX_AT]))
						then starttimer(S,MAX_AT,MAX_AT) + insert(waitingForAnswer).
					
					% Cycle through multiple choice options, start timer for question state with touch response and set waitingForAnswer flag.
					% when events have been completed (and we're not already waiting for an answer).	
					if bel(keyListValues(T, S, [type, maxAnswerTimeTouch, options], [Type, MAX_AT, Values]), Type \= yesno,
							mcCounter(C), nth0(C, Values, Value), atom_string(Value, String))
						then say(String) + starttimer(S,MAX_AT,MAX_AT) + insert(waitingForAnswer).
				}
		}
}