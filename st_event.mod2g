use dialogflow as knowledge.
use script as knowledge.
use dialogflow as actionspec.

module st_event {
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% Percept processing                %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% NAO event percepts
	if percept(event(E)), not(bel(event(E)))
		then insert(event(E)).
	if bel(event(E)), not(percept(event(E)))
		then delete(event(E)).
	
	% DialogFlow: Processing recognized intents (assuming these are always replies/answers here).
	% Stop listening if we received an answer.
	% Need to check here for cases Params=[] as we sometimes get this from DialogFlow even with required parameters(!?) : (Params=[] -> Type=yesno ; nth0(0, Params, _))
	if percept(intent(Type, Params)), bel(currentState(S), waitingForAnswer)
		then delete(waitingForAnswer) + insert(answer(S, Type, Params))
			+ stopListening + canceltimer(S). % (doesn't harm to perform stopListening if robot is not listening)
	
	if percept(audioRecording(FileName)), bel(currentState(S), waitingForAudio)
		then delete(waitingForAudio) + insert(audioRecording(S, FileName)).

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% Event and timeout logic           %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% Handling of event waiting logic...
	% ... for NAO events
	if bel(event(E), waitingForEvent(E))
		then delete(waitingForEvent(E)).
	
	% Right bumper means yes and left bumper means no (if current state is yes/no question with touch response).
	if bel(feetBumperEventAnswer(Type), currentState(S), waitingForAnswer, keyListValues(S, [type, response], [yesno, touch]))
		then delete(waitingForAnswer) + insert(answer(S, Type, [])) + canceltimer(S).
		
	% Right bumper means current option is selected (if current state is mc question with touch response).
	if bel(feetBumperEventAnswer('answer_yes'), currentState(S), waitingForAnswer,
		keyListValues(S, [type, response, context, options], [mc, touch, Type, Values]), mcCounter(C), nth0(C, Values, Answer))
		then delete(waitingForAnswer) + insert(answer(S, Type, [Answer])) + canceltimer(S).
	% Left bumper means current option is NOT selected (if current state is mc question with touch response).
	if bel(feetBumperEventAnswer('answer_no'), currentState(S), waitingForAnswer,
		keyListValues(S, [type, response], [mc, touch]), mcCounter(C), newC is C + 1)
		then delete(waitingForAnswer, mcCounter(C)) + insert(mcCounter(newC)) + canceltimer(S).
	% Handle case where we have run out of options for mc question (fail).
	if bel(mcCounter(C), currentState(S), keyValue(S, options, Values), length(Values, L), C=L)
		then insert(answer(S, 'fail', [])).
		
	% ... for answers to questions
	if bel(currentState(S), answer(S, Type, _), nextCondition(C), not(C=Type))
		then delete(nextCondition(C)) + insert(nextCondition(Type)).
	% store (specific) answers to questions in answers-list (if not already done and question is not yes/no question);
	% assumes reply is a list with single item (Answer).
	if bel(answer(S, Type, [Answer]), state(_, S, question), not(keyValue(S, type, yesno)), answers(Answers),
		keyListValues(S, [context, key], [Type, Key]), updateAnswers(Answers, Key, Answer, NewAnswers))
		then delete(answers(Answers)) + insert(answers(NewAnswers)).

	% Detecting timeouts
	if percept(timer(S, _)), not(bel(timeout(S)))
		then insert(timeout(S)) + log(timeout(S)).
	if bel(timeout(S)), not(percept(timer(S, _)))
		then delete(timeout(S)).

	% Handling timeouts (important to do this after other event processing above!).
	if bel(currentState(S), state(_, S, question), timeout(S), waitingForAnswer,
		keyValue(S, maxAnswerAttempts, MaxAnswerAttempts),
		currentAttempt(CurrentAttempt), NextAttempt is CurrentAttempt + 1)
	then { % (doesn't harm to perform stopListening if robot is not listening, e.g., using bumpers for input)
		if bel(CurrentAttempt < MaxAnswerAttempts, not(keyListValues(S, [type, response], [mc, touch])))
			then stopListening + delete(started, waitingForAnswer, currentAttempt(CurrentAttempt)) + insert(start, currentAttempt(NextAttempt)).
		if bel(CurrentAttempt >= MaxAnswerAttempts, not(keyListValues(S, [type, response], [mc, touch])), nextCondition(C))
			% we need to leave the state, so insert fake answer for completion but with a 'fail' condition (substituted for default next condition).
		then stopListening + delete(waitingForAnswer, currentAttempt(CurrentAttempt), nextCondition(C))
				+ insert(answer(S, 'fail', []), nextCondition('fail'), currentAttempt(1)).
		if bel(keyListValues(S, [type, response], [mc, touch]), mcCounter(C), Cnew is C + 1)
			then delete(waitingForAnswer, mcCounter(C)) + insert(mcCounter(Cnew)).
	} % TODO: give some time after stopListening for an answer to come in from dialogflow
	
	if bel(currentState(S), state(_, S, audioInput), timeout(S), waitingForAudio)
		then stopListening + delete(waitingForAudio).

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% (Internal) state transition handling %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	%% Question state
	if bel(currentState(S), state(_, S, question), eventsCompleted, not(waitingForAnswer), not(answer(_, _, _)))
	then {
		% Start listening (with timeout by starting timer) and set waitingForAnswer flag.
		% when events have been completed (and we're not already waiting for an answer).
		if bel(keyListValues(S, [response, context, maxAnswerTime], [speech, C, MAX_AT]))
		then startListening(C) + starttimer(S, MAX_AT, MAX_AT) + insert(waitingForAnswer).
		
		% Start timer for question state with touch response and set waitingForAnswer flag.
		% when events have been completed (and we're not already waiting for an answer).
		if bel(keyListValues(S, [type, response, maxAnswerTime], [yesno, touch, MAX_AT]))
		then starttimer(S,MAX_AT,MAX_AT) + insert(waitingForAnswer).
		
		% Cycle through multiple choice options, start timer for question state with touch response and set waitingForAnswer flag.
		% when events have been completed (and we're not already waiting for an answer).
		if bel(keyListValues(S, [type, response, maxAnswerTime, options], [mc, touch, MAX_AT, Values]),
			mcCounter(C), nth0(C, Values, Value), atom_string(Value, String))
		then say(String) + starttimer(S,MAX_AT,MAX_AT) + insert(waitingForAnswer).
		
		% Add defaultAnswer (if any is given for question state)
		if bel(keyListValues(S, [key, defaultAnswer], [Key, Answer]), answers(Answers), updateAnswers(Answers, Key, Answer, NewAnswers))
			then delete(answers(Answers)) + insert(answers(NewAnswers)).
	}
	
	% Audio handling
	if bel(currentState(S), state(_, S, audioInput), eventsCompleted, not(waitingForAudio), not(audioRecording(_,_)),
		keyListValues(S, [recordTime], [RT]))
		then startListening + starttimer(S, RT, RT) + insert(waitingForAudio).


	%% State transition handling
	% If state has been completed,  
	if bel(currentTopic(T), completed(S), nextCondition(C))
	then { % ... clean up (and reset nextCondition to default value 'true') ...
		% Cleanup: remove all answers (if any).
		forall bel(answer(S, I, Params)) do delete(answer(S, I, Params)).
		% Cleanup: remove state specific parameters (if any).
		if bel(keyValue(S, options, _), mcCounter(C)) then delete(mcCounter(C)).
		% Cleanup: Remove current, completed state and reset state tracking parameters to their default values.
		if bel(currentAttempt(Attempt))
			then delete(currentState(S), started, nextCondition(C), currentAttempt(Attempt))
				+ insert(start, nextCondition('true'), currentAttempt(1)).

		% ... and transition to next state (if there is one) ...
		if bel(next(T, S, C, Snext))
			then insert(currentState(Snext)). % Progress: move to next state
			
		% ... or go to next topic if a topic has been completed (no next state has been specified for the topic).
		if goal(topics(AllTopics)), not(bel(next(T, S, C, _)))
		then {
			if bel(topics(TopicsDone), append(TopicsDone, [T], NewTopicsDone))
				then delete(topics(TopicsDone)) + insert(topics(NewTopicsDone)).
			% get new topic (if any is left).
			if bel(topics(TopicsDone), append(TopicsDone, [H | _], AllTopics))
				then delete(currentTopic(T)) + insert(currentTopic(H), currentState(s1)).
		}
				
		% And, finally, initialize state specific parameters for new state (if any).
		if bel(currentState(Snow), keyValue(Snow, options, _)) then insert(mcCounter(0)).
	}
}