use dialogflow as knowledge.
use script as knowledge.
use dialogflow as actionspec.
use 'recognitionAndRepairePipeline/startAnswerRecognition' as module.
use 'recognitionAndRepairePipeline/retrieveInput' as module.
use 'recognitionAndRepairePipeline/repair' as module.
use 'recognitionAndRepairePipeline/processAnswer' as module.

module st_event {
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% Percept and event processing      %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% NAO event percepts
	forall percept(event(E)), not(bel(event(E)))
		do insert(event(E)).
	forall bel(event(E)), not(percept(event(E)))
		do delete(event(E)).
		
	% Handling of event waiting logic...
	% ... for NAO events
	if bel(event(E), waitingForEvent(E))
		then delete(waitingForEvent(E)).
	
	% Handling timeouts
	if percept(timer(S, _)), not(bel(timeout(S)))
		then insert(timeout(S)).
	if bel(timeout(S)), not(percept(timer(S, _)))
		then delete(timeout(S)).
		
	%Audio recording percepts
	if percept(audioRecording(FileName)), bel(currentState(S), waitingForAudio)
		then delete(waitingForAudio) + insert(audioRecording(S, FileName)).
	
	%Emotion detection percepts
	if percept(emotionDetected(Emotion)), bel(currentState(S))
		then insert(emotion(S, Emotion)) + delete(waitingForEmotion) + log(Emotion) + stopWatching.

	%% Dialogflow tweaks %%
	% Cut of listening if user already answered something that did not match anything.
	if percept(speechText(Text)), bel(currentState(S), waitingForAnswer, currentInputModality(speech), currentAttempt(CurrentAttempt))
		then stopListening + canceltimer(S) + canceltimer(dialogflow) + insert(timeout(dialogflow), speechText(S, CurrentAttempt, Text)).
		
	% Adding 1000ms additional waiting time after stop streaming audio to dialogflow.
	if bel(currentTopic(T), currentState(S), state(T, S, question), timeout(S), waitingForAnswer, currentInputModality(speech))
		then stopListening + starttimer(dialogflow, 1000, 1000).
		
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% Recognition and Repair            %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	%%% SPEECH %%%
	% Dialogflow produces an input. Retrieve answer.
	if percept(intent(Intent, Params)), bel(currentTopic(T), currentState(S), state(T, S, question), waitingForAnswer)
		then retrieveInput(T, S, Intent, Params).
		
	% Dialogflow does not produce an input. Try a repair action.
	if bel(currentTopic(T), currentState(S), state(T, S, question), waitingForAnswer, timeout(dialogflow))
		then repair(T, S).
	
	%%% TOUCH %%%
	% An answer has been selected. Retrieve answer.
	if bel(currentTopic(T), currentState(S), state(T, S, question), waitingForAnswer, feetBumperEventAnswer(Intent))
		then retrieveInput(T, S, Intent, []).
	
	% No answer has been selected. Try a repair action.
	if bel(currentTopic(T), currentState(S), state(T, S, question), timeout(S), waitingForAnswer)
		then repair(T, S).
		
	%%% AUDIO RECORDING %%%
	% When timeout occurs while waiting for audio the audio recording is completed. Stop listening (and waiting for audio input). 
	if bel(currentTopic(Topic), currentState(S), state(Topic, S, audioInput), timeout(S), waitingForAudio)
		then stopListening + disableRecording.

	%%% EMOTION RECOGNITION %%%	
	% When timeout occurs while waiting for emotion, emotion detection is stopped.
	if bel(currentTopic(Topic), currentState(S), state(Topic, S, emotion), timeout(S), waitingForEmotion, not(emotion(S,_)))
		then stopWatching + insert(emotion(S, 'fail')) + delete(waitingForEmotion).
		
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% Answer processing			      %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	%Given an answer(T, S, Ans, Details) and the type of question (yesno, input, branch, quiz) the answers should be processed differently.
	if bel(currentTopic(T), currentState(S), answer(T,S, Ans, _), not(answerProcessed))
		then processAnswer(T, S, Ans).
		
	% If the state is a branching point, retrieve the decision and insert that as the nextCondition.
	if bel(currentTopic(T), currentState(S), state(T, S, branchingPoint), getBranchingPointDecision([T, S], Decision), nextCondition(Con))
		then delete(nextCondition(Con)) + insert(nextCondition(Decision)).
		
	% If an emotion is expected and present, set that as the next condition.
	if bel(currentTopic(T), currentState(S), state(T, S, emotion), emotion(S,Emotion), nextCondition(Con), not(Con=Emotion))
		then delete(nextCondition(Con)) + insert(nextCondition(Emotion)).

		
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% Start recognition for answers, audio, and emotions  %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	% Question
	if bel(currentTopic(T), currentState(S), state(T, S, question), eventsCompleted, not(waitingForAnswer), not(answer(T, S, _, _)))
		then startAnswerRecognition(T, S).
		
	% Audiorecording
	if bel(currentTopic(T), currentState(S), state(T, S, audioInput), not(waitingForAudio), not(audioRecording(S,_)),
		keyListValues(T, S, recordTime, RT))
		then enableRecording + startListening + starttimer(S, RT, RT) + insert(waitingForAudio).
	
	% Emotion
	if bel(currentTopic(T), currentState(S), state(T, S, emotion), not(waitingForEmotion), not(emotion(S,_)))
		then startWatching + starttimer(S, 6000, 6000) + insert(waitingForEmotion).

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% State transition handling            %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% If state has been completed,  
	if bel(currentTopic(T), completed(S), nextCondition(C))
	then { % ... clean up (and reset nextCondition to default value 'true') ...
		% reset answers processing flag
		if bel(answerProcessed) then delete(answerProcessed).
		
		% Cleanup: remove state specific parameters (if any).	
		if bel(state(T, S, question), modalityCounter(ModCount), currentInputModality(Modality), currentAttempt(Attempt), mcCounter(Count))
			then delete(modalityCounter(ModCount), currentInputModality(Modality), currentAttempt(Attempt), mcCounter(Count)). 
		
		% Cleanup: Remove current, completed state and reset state tracking parameters to their default values.
		if bel(currentState(S), started)
			then delete(currentState(S), started, nextCondition(C))
				+ insert(start, nextCondition('true')).
	
		% ... and transition to next state (if there is one) ...
		if bel(next(T, S, C, Snext))
			then insert(currentState(Snext)). % Progress: move to next state
			
		% ... or go to next topic if a topic has been completed (no next state has been specified for the topic).
		if goal(topics(AllTopics)), not(bel(next(T, S, C, _)))
		then {
			if bel(topics(TopicsDone), append(TopicsDone, [T], NewTopicsDone))
				then delete(topics(TopicsDone)) + insert(topics(NewTopicsDone)).
			% get new topic (if any is left).
			if bel(topics(TopicsDone), append(TopicsDone, [H | _], AllTopics))
				then delete(currentTopic(T)) + insert(currentTopic(H), currentState(s1)).
		}
				
		% And, finally, initialize state specific parameters for new state (if any).
		if bel(currentTopic(Tnew), currentState(Snew), state(Tnew, Snew, question), keyValue(Tnew, Snew, inputModalityOrder, Order), nth0(0, Order, NewModality)) 
			then insert(currentInputModality(NewModality), modalityCounter(0), currentAttempt(1), mcCounter(0)).
	}
}