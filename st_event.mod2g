use dialogflow as knowledge.
use script as knowledge.
use dialogflow as actionspec.

module st_event {
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% Percept processing                %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% NAO event percepts
	if percept(event(E)), not(bel(event(E)))
		then insert(event(E)).
	if bel(event(E)), not(percept(event(E)))
		then delete(event(E)).
	
	% DialogFlow: Processing recognized intents (assuming these are always replies/answers here).
	% Stop listening if we received an answer.
	% Need to check here for cases Params=[] as we sometimes get this from DialogFlow even with required parameters(!?) : (Params=[] -> Type=yesno ; nth0(0, Params, _))
	if percept(intent(Intent, Params)), bel(currentState(S), waitingForAnswer, keyListValues(S, [context], [Context]))
		then delete(waitingForAnswer) + insert(answer(S, Context, Intent, Params))
			+ stopListening + canceltimer(S). % (doesn't harm to perform stopListening if robot is not listening)
	
	if percept(audioRecording(FileName)), bel(currentState(S), waitingForAudio)
		then delete(waitingForAudio) + insert(audioRecording(S, FileName)).

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% Event and answer logic            %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% Handling of event waiting logic...
	% ... for NAO events
	if bel(event(E), waitingForEvent(E))
		then delete(waitingForEvent(E)).
	
	% Right bumper means yes and left bumper means no (if current state is yes/no question with touch response).
	if bel(feetBumperEventAnswer(Intent), currentState(S), waitingForAnswer, keyListValues(S, [type, response, context], [yesno, touch, Context]))
		then delete(waitingForAnswer) + insert(answer(S, Context, Intent, [])) + canceltimer(S).
		
	% Right bumper means current option is selected (if current state is mc question with touch response).
	if bel(feetBumperEventAnswer('answer_yes'), currentState(S), waitingForAnswer,
		keyListValues(S, [type, response, context, options], [mc, touch, Context, Values]), mcCounter(C), nth0(C, Values, Answer))
		then delete(waitingForAnswer) + insert(answer(S, Context, Context, [Answer])) + canceltimer(S).
	% Left bumper means current option is NOT selected (if current state is mc question with touch response).
	if bel(feetBumperEventAnswer('answer_no'), currentState(S), waitingForAnswer,
		keyListValues(S, [type, response], [mc, touch]), mcCounter(C), newC is C + 1)
		then delete(waitingForAnswer, mcCounter(C)) + insert(mcCounter(newC)) + canceltimer(S).
	% Handle case where we have run out of options for mc question (fail).
	if bel(mcCounter(C), currentState(S), keyListValues(S, [options, context], [Values, Context]), length(Values, L), C=L)
		then insert(answer(S, Context, 'fail', [])).
	% Prepaire the nextCondition (excluding altEnding).
	if bel(currentState(S), not(keyValue(S, altEnding, yes)), not(keyValue(S, branching, yes)), answer(S, _, Intent, _), nextCondition(C), not(C=Intent))
		then delete(nextCondition(C)) + insert(nextCondition(Intent)).
	% Prepaire the nextCondition in the case branching is true and the user answer via the bumpers. %ToDo fix this.
	if bel(currentState(S), not(keyValue(S, altEnding, yes)), keyValue(S, branching, yes), answer(S, _, _, [Answer]), nextCondition(C), not(C=Answer))
		then delete(nextCondition(C)) + insert(nextCondition(Answer)).
	if bel(currentState(S), not(keyValue(S, altEnding, yes)), keyValue(S, branching, yes), answer(S, _, Intent, []), nextCondition(C), not(C=Intent))
		then delete(nextCondition(C)) + insert(nextCondition(Intent)).
	%Prepaire nextConditions for alternative ending.
	if bel(currentState(S), keyListValues(S, [selectEnding, key], [yes, Key]), getAnswer(Key, Answer), nextCondition(C), not(C=Answer))
		then delete(nextCondition(C)) + insert(nextCondition(Answer)).
	% store answers to questions in answers-list (if not already done and question is not yes/no question);
	% assumes reply is a list with single item (Answer).
	% If there is a specific answer store that answer (e.g. Entity recognized).
	if bel(answer(S, Context, _, [Answer]), state(_, S, question), not(keyValue(S, type, yesno)), answers(Answers),
		keyListValues(S, [context, key], [Context, Key]), updateAnswers(Answers, Key, Answer, NewAnswers))
		then delete(answers(Answers)) + insert(answers(NewAnswers)).
	% If the intent itself is the answer (and no specific entity is known), store that answer.
	if bel(answer(S, _, Intent, []), not(Intent="fail"), state(_, S, question), not(keyValue(S, type, yesno)), answers(Answers),
		keyValue(S, key, Key), updateAnswers(Answers, Key, Intent, NewAnswers))
		then delete(answers(Answers)) + insert(answers(NewAnswers)).
	
	% If the touch based repair mechanism fails to give an answer, use the default answer if there is any.
	if bel(answer(S, _, "fail", []), state(_, S, question), keyListValues(S, [response, key, defaultAnswer], [touch, Key, Answer]), 
		answers(Answers), updateAnswers(Answers, Key, Answer, NewAnswers))
		then delete(answers(Answers)) + insert(answers(NewAnswers)).


	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% Timeout logic		              %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% Detecting timeouts
	if percept(timer(S, _)), not(bel(timeout(S)))
		then insert(timeout(S)) + log(timeout(S)).
	if bel(timeout(S)), not(percept(timer(S, _)))
		then delete(timeout(S)).

	% Handling timeouts (important to do this after other event processing above!).
	if bel(currentTopic(Topic), currentState(S), state(Topic, S, question), timeout(S), waitingForAnswer,
		keyValue(S, maxAnswerAttempts, MaxAnswerAttempts),
		currentAttempt(CurrentAttempt), NextAttempt is CurrentAttempt + 1)
	then { % (doesn't harm to perform stopListening if robot is not listening, e.g., using bumpers for input)
		if bel(CurrentAttempt < MaxAnswerAttempts, not(keyListValues(S, [type, response], [mc, touch])))
			then stopListening + delete(started, waitingForAnswer, currentAttempt(CurrentAttempt)) + insert(start, currentAttempt(NextAttempt)).
		if bel(CurrentAttempt >= MaxAnswerAttempts, not(keyListValues(S, [type, response], [mc, touch])))
		% we run out of attempts so we stop listening here but start a new timer (1s) to still wait a little longer for response from dialogflow.
		then stopListening + starttimer(dialogflow, 1000, 1000) + delete(currentAttempt(CurrentAttempt)) + insert(currentAttempt(1)).
		
		if bel(keyListValues(S, [type, response], [mc, touch]), mcCounter(C), Cnew is C + 1)
			then delete(waitingForAnswer, mcCounter(C)) + insert(mcCounter(Cnew)).
	}
	
	% Handle case with timer to delay moving to next state to wait longer for response from dialogflow.
	% If this timer has timed out, and we still have no answer, we need to leave the state, and
	% we insert a fake answer for completion but with a 'fail' condition (substituted for default next condition).
	if bel(currentTopic(Topic), currentState(S), state(Topic, S, question), keyValue(S, context, Context), timeout(dialogflow), waitingForAnswer, nextCondition(C))
		then delete(waitingForAnswer, nextCondition(C)) + insert(answer(S, Context, 'fail', []), nextCondition('fail')).
	
	% When timeout occurs while waiting for audio, audio recording is completed, so stop listening (and waiting for audio input). 
	if bel(currentState(S), state(_, S, audioInput), timeout(S), waitingForAudio)
		then stopListening + delete(waitingForAudio).

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% Setting things up for input handling %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% Question
	if bel(currentState(S), state(_, S, question), eventsCompleted, not(waitingForAnswer), not(answer(_, _, _, _)))
	then {
		% Start listening (with timeout by starting timer) and set waitingForAnswer flag.
		% when events have been completed (and we're not already waiting for an answer).
		if bel(keyListValues(S, [response, context, maxAnswerTime], [speech, C, MAX_AT]))
		then startListening(C) + starttimer(S, MAX_AT, MAX_AT) + insert(waitingForAnswer).
		
		% Start timer for question state with touch response and set waitingForAnswer flag.
		% when events have been completed (and we're not already waiting for an answer).
		if bel(keyListValues(S, [type, response, maxAnswerTime], [yesno, touch, MAX_AT]))
		then starttimer(S,MAX_AT,MAX_AT) + insert(waitingForAnswer).
		
		% Cycle through multiple choice options, start timer for question state with touch response and set waitingForAnswer flag.
		% when events have been completed (and we're not already waiting for an answer).
		if bel(keyListValues(S, [type, response, maxAnswerTime, options], [mc, touch, MAX_AT, Values]),
			mcCounter(C), nth0(C, Values, Value), atom_string(Value, String))
		then say(String) + starttimer(S,MAX_AT,MAX_AT) + insert(waitingForAnswer).
	}
	
	% Audiorecording
	if bel(currentState(S), state(_, S, audioInput), eventsCompleted, not(waitingForAudio), not(audioRecording(_,_)),
		keyListValues(S, [recordTime], [RT]))
		then startListening + starttimer(S, RT, RT) + insert(waitingForAudio).

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% State transition handling            %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% If state has been completed,  
	if bel(currentTopic(T), completed(S), nextCondition(C))
	then { % ... clean up (and reset nextCondition to default value 'true') ...
		% Cleanup: remove all answers (if any).
		forall bel(answer(S, Context, I, Params)) do delete(answer(S, Context, I, Params)).
		% Cleanup: remove state specific parameters (if any).
		if bel(keyValue(S, options, _), mcCounter(C)) then delete(mcCounter(C)).
		% Cleanup: Remove current, completed state and reset state tracking parameters to their default values.
		if bel(currentAttempt(Attempt))
			then delete(currentState(S), started, nextCondition(C), currentAttempt(Attempt))
				+ insert(start, nextCondition('true'), currentAttempt(1)).

		% ... and transition to next state (if there is one) ...
		if bel(next(T, S, C, Snext))
			then insert(currentState(Snext)). % Progress: move to next state
			
		% ... or go to next topic if a topic has been completed (no next state has been specified for the topic).
		if goal(topics(AllTopics)), not(bel(next(T, S, C, _)))
		then {
			if bel(topics(TopicsDone), append(TopicsDone, [T], NewTopicsDone))
				then delete(topics(TopicsDone)) + insert(topics(NewTopicsDone)).
			% get new topic (if any is left).
			if bel(topics(TopicsDone), append(TopicsDone, [H | _], AllTopics))
				then delete(currentTopic(T)) + insert(currentTopic(H), currentState(s1)).
		}
				
		% And, finally, initialize state specific parameters for new state (if any).
		if bel(currentState(Snow), keyValue(Snow, options, _)) then insert(mcCounter(0)).
	}
}