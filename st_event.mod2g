use dialogflow as knowledge.
use dialogflow as actionspec.

module st_event {
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% Percept processing                %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% NAO event percepts
	if percept(event(E)), not(bel(event(E))) 
		then insert(event(E)).
	if bel(event(E)), not(percept(event(E)))
		then delete(event(E)).
	
	% DialogFlow: Processing recognized intents (assuming these are always replies/answers here).
	% Need to check here for cases Params=[] as we sometimes get this from DialogFlow even with required parameters(!?) : (Params=[] -> Type=yesno ; nth0(0, Params, _))
	if percept(intent(Type, Params)), bel(currentState(S), waitingForAnswer)
		then delete(waitingForAnswer) + insert(answer(S, Type, Params))
			+ stopListening + canceltimer(S). % (doesn't harm to perform stopListening if robot is not listening)

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% Event and timeout logic           %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% Handling of event waiting logic...
	% ... for NAO events
	if bel(event(E), waitingForEvent(E))
		then delete(waitingForEvent(E)).
	
	% Right bumper means yes and left bumper means no (if current state is yesno question with touch response)
	if bel(feetBumperEventAnswer(Type), currentState(S), waitingForAnswer, state(S, question), keyListValues(S, [type, response], [yesno, touch]))
		then delete(waitingForAnswer) + insert(answer(S, Type, [])).
		
	% ... for answers to questions (stop listening if we received an answer)
	if bel(currentState(S), answer(S, Type, _), nextCondition(C), not(C=Type))
		then delete(nextCondition(C)) + insert(nextCondition(Type)).
	% store (specific) answers to questions in answers-list (if not already done and question is not yes/no question);
	% assumes reply is a list with single item (Answer).
	if bel(answer(S, Type, [Answer]), state(S, question), not(keyValue(S, type, yesno)), answers(Answers),
		keyListValues(S, [context, key], [Type, Key]), not(member((Key=Answer), Answers)),
		append(Answers, [Key=Answer], NewAnswers))
		then delete(answers(Answers)) + insert(answers(NewAnswers)).

	% Detecting timeouts
	if percept(timer(S, _)), not(bel(timeout(S)))
		then insert(timeout(S)) + log(timeout(S)).
	if bel(timeout(S)), not(percept(timer(S, _)))
		then delete(timeout(S)).

	% Handling timeouts (important to do this after other event processing above!).
	if bel(currentState(S), state(S, question), timeout(S), waitingForAnswer,
		keyValue(S, maxAnswerAttempts, MaxAnswerAttempts),
		currentAttempt(CurrentAttempt), NextAttempt is CurrentAttempt + 1)
	then { % (doesn't harm to perform stopListening if robot is not listening, e.g., using bumpers for input)
		if bel(CurrentAttempt < MaxAnswerAttempts)
			then stopListening + delete(started, waitingForAnswer, currentAttempt(CurrentAttempt)) + insert(start, currentAttempt(NextAttempt)).
		if bel(CurrentAttempt >= MaxAnswerAttempts, nextCondition(C))
			% we need to leave the state, so insert fake answer for completion but with a 'fail' condition (substituted for default next condition).
			then stopListening + delete(waitingForAnswer, currentAttempt(CurrentAttempt), nextCondition(C))
				+ insert(answer(S, 'fail', []), nextCondition('fail'), currentAttempt(1)).
	}
		
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% (Internal) state transition handling %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	%% Question state
	% Start listening (with timeout by starting timer) and set waitingForAnswer flag
	% when events have been completed (and we're not already waiting for an answer).
	if bel(currentState(S), state(S, question), eventsCompleted, not(waitingForAnswer), not(answer(_, _, _)), 
		keyListValues(S, [response, context, maxAnswerTime], [speech, C, MAX_AT]))
		then startListening(C) + starttimer(S, MAX_AT, MAX_AT) + insert(waitingForAnswer).
		
	% Start timer for question state with touch response and set waitingForAnswer flag
	% when events have been completed (and we're not already waiting for an answer).
	if bel(currentState(S), state(S, question), eventsCompleted, not(waitingForAnswer), not(answer(_, _, _)),
		keyListValues(S, [type, response, maxAnswerTime], [yesno, touch, MAX_AT]))
		then starttimer(S,MAX_AT,MAX_AT) + insert(waitingForAnswer).
		
	%Multiple choice (mc) question
		% if bel(Type=mc) TODO
			%then do something else

	%% State transition handling
	% If state has been completed, then transition to next state (and reset nextCondition to default value 'true').
	if bel(currentState(S1), completed(S1), nextCondition(C), next(S1, C, S2))
		% cleanup (remove current state, nextCondition, and other state tracking facts.)
	then {
		if true then delete(currentState(S1), nextCondition(C), started) + insert(currentState(S2), start, nextCondition('true')).
		% If state has been completed (S1), remove all answers (if any).
		forall bel(answer(S1, I, Params)) do delete(answer(S1, I, Params)).
	}
}