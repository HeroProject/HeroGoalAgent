use dialogflow as knowledge.
use script as knowledge.
use dialogflow as actionspec.

module st_event {
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% Percept processing                %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% NAO event percepts
	forall percept(event(E)), not(bel(event(E)))
		do insert(event(E)).
	forall bel(event(E)), not(percept(event(E)))
		do delete(event(E)).
	
	% DialogFlow: Processing recognized intents (assuming these are always replies/answers here).
	% Stop listening if we received an answer.
	% Need to check here for cases Params=[] as we sometimes get this from DialogFlow even with required parameters(!?) : (Params=[] -> Type=yesno ; nth0(0, Params, _))
	if percept(intent(Intent, Params)), bel(currentState(S), waitingForAnswer, keyListValues(S, [context, numParams], [Context, NumParams]), length(Params, NumParams))
	
		then delete(waitingForAnswer) + insert(answer(S, Context, Intent, Params))
			+ stopListening + canceltimer(S) + log(Intent) + log(Params). % (doesn't harm to perform stopListening if robot is not listening)

	%Audio recording
	if percept(audioRecording(FileName)), bel(currentState(S), waitingForAudio)
		then delete(waitingForAudio) + insert(audioRecording(S, FileName)).
	
	%Emotion detection
	if percept(emotionDetected(Emotion)), bel(currentState(S))
		then insert(emotion(S, Emotion)) + delete(waitingForEmotion) + log(Emotion) + stopWatching.

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% Event and answer logic            %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% Handling of event waiting logic...
	% ... for NAO events
	if bel(event(E), waitingForEvent(E))
		then delete(waitingForEvent(E)).
	
	% Right bumper means yes and left bumper means no (if current state is yes/no question with touch response).
	if bel(feetBumperEventAnswer(Intent), currentState(S), waitingForAnswer, keyListValues(S, [type, response, context], [yesno, touch, Context]))
		then delete(waitingForAnswer) + insert(answer(S, Context, Intent, [])) + canceltimer(S).
		
	% Right bumper means current option is selected (if current state is mc question with touch response).
	if bel(feetBumperEventAnswer('answer_yes'), currentState(S), waitingForAnswer,
		keyListValues(S, [type, response, context, options], [mc, touch, Context, Values]), mcCounter(C), nth0(C, Values, Answer))
		then delete(waitingForAnswer) + insert(answer(S, Context, Context, [Answer])) + canceltimer(S).
	% Left bumper means current option is NOT selected (if current state is mc question with touch response).
	if bel(feetBumperEventAnswer('answer_no'), currentState(S), waitingForAnswer,
		keyListValues(S, [type, response], [mc, touch]), mcCounter(C), Cnew is C + 1)
		then delete(waitingForAnswer, mcCounter(C)) + insert(mcCounter(Cnew)) + canceltimer(S).
	% Handle case where we have run out of options for mc question (fail).
	if bel(mcCounter(C), currentState(S), keyListValues(S, [options, context, maxAnswerAttempts], [Values, Context, MaxAnswerAttempts]), 
		length(Values, L), C=L, currentAttempt(CurrentAttempt))
		then {
			if bel(CurrentAttempt >= MaxAnswerAttempts, nextCondition(Con))
				then delete(currentAttempt(CurrentAttempt), waitingForAnswer, nextCondition(Con)) + 
					insert(currentAttempt(1), answer(S, Context, 'fail', []), nextCondition('fail')) + log(failed(S)).					
			if bel(CurrentAttempt < MaxAnswerAttempts, NextAttempt is CurrentAttempt + 1)
				then delete(started, waitingForAnswer, currentAttempt(CurrentAttempt), mcCounter(C)) + 
					insert(start, currentAttempt(NextAttempt), mcCounter(0)).
		}
	% Prepaire the nextCondition (excluding altEnding).
	if bel(currentState(S), not(keyValue(S, altEnding, yes)), not(keyValue(S, branching, yes)), answer(S, _, Intent, _), nextCondition(C), not(C=Intent))
		then delete(nextCondition(C)) + insert(nextCondition(Intent)).
	% Prepaire the nextCondition in the case branching is true and the user answer via the bumpers. %ToDo fix this.
	if bel(currentState(S), not(keyValue(S, altEnding, yes)), keyValue(S, branching, yes), answer(S, _, _, [Answer]), nextCondition(C), not(C=Answer))
		then delete(nextCondition(C)) + insert(nextCondition(Answer)).
	if bel(currentState(S), not(keyValue(S, altEnding, yes)), keyValue(S, branching, yes), answer(S, _, Intent, []), nextCondition(C), not(C=Intent))
		then delete(nextCondition(C)) + insert(nextCondition(Intent)).
	%Prepaire nextConditions for alternative ending.
	if bel(currentState(S), keyListValues(S, [selectEnding, key], [yes, Key]), getAnswer(Key, Answer), nextCondition(C), not(C=Answer))
		then delete(nextCondition(C)) + insert(nextCondition(Answer)).
	% store answers to questions in answers-list (if not already done and question is not yes/no question);
	% assumes reply is a list with single item (Answer).
	% If there is a specific answer store that answer (e.g. Entity recognized).
	if bel(answer(S, Context, _, [Answer]), state(_, S, question), not(keyValue(S, type, yesno)), answers(Answers),
		keyListValues(S, [context, key], [Context, Key]), updateAnswers(Answers, Key, Answer, NewAnswers))
		then delete(answers(Answers)) + insert(answers(NewAnswers)).
	% If the intent itself is the answer (and no specific entity is known), store that answer.
	if bel(answer(S, _, Intent, []), not(Intent="fail"), state(_, S, question), not(keyValue(S, type, yesno)), answers(Answers),
		keyValue(S, key, Key), updateAnswers(Answers, Key, Intent, NewAnswers))
		then delete(answers(Answers)) + insert(answers(NewAnswers)).
	
	% If the touch based repair mechanism fails to give an answer, use the default answer if there is any.
	if bel(answer(S, _, "fail", []), state(_, S, question), keyListValues(S, [response, key, defaultAnswer], [touch, Key, Answer]), 
		answers(Answers), updateAnswers(Answers, Key, Answer, NewAnswers))
		then delete(answers(Answers)) + insert(answers(NewAnswers)).
	
	% If an emotion is expected and present, set that as the next condition.
	if bel(currentState(S), state(_, S, emotion), emotion(S,E), nextCondition(C), not(C=E))
		then delete(nextCondition(C)) + insert(nextCondition(E)).


	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% Timeout logic		              %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% Detecting timeouts
	if percept(timer(S, _)), not(bel(timeout(S)))
		then insert(timeout(S)).
	if bel(timeout(S)), not(percept(timer(S, _)))
		then delete(timeout(S)).
	if percept(timer(S, _), S \= dialogflow) 
		then log(timeout(S)).
	if percept(speechText(Text)), bel(currentState(S), waitingForAnswer, currentAttempt(CurrentAttempt)) % heard something but it didn't match what we want
		then stopListening + canceltimer(S) + canceltimer(dialogflow) + insert(timeout(dialogflow), speechText(S, CurrentAttempt, Text)).

	% Handling timeouts (important to do this after other event processing above!).
	% Adding 1000ms additional waiting time after stop streaming audio to dialogflow.
	if bel(currentTopic(Topic), currentState(S), state(Topic, S, question), timeout(S), waitingForAnswer)
		then stopListening + starttimer(dialogflow, 1000, 1000).
		
	% If this timer has timed out, and we still have no answer, we need to leave the state, and
	% we insert a fake answer for completion but with a 'fail' condition (substituted for default next condition).
	if bel(currentTopic(Topic), currentState(S), state(Topic, S, question), keyValue(S, context, Context), waitingForAnswer,
		timeout(dialogflow), keyValue(S, maxAnswerAttempts, MaxAnswerAttempts), currentAttempt(CurrentAttempt))
	then {
		%If the number of attempts are reached and the user attempted to answer the first time, the speech recognition part failed.
		if bel(started, CurrentAttempt >= MaxAnswerAttempts, speechText(S, 1, _), not(keyListValues(S, [type, response], [mc, touch])), nextCondition(C))
			then delete(currentAttempt(CurrentAttempt), waitingForAnswer, nextCondition(C))
			+ insert(currentAttempt(1), answer(S, Context, 'fail', []), nextCondition('fail')) + log(failed(S)).				
		
		%If the number of attempts are reached and the user and if and only if the user did not used the first attempt, the user gets one additional attempt.
		if bel(started, CurrentAttempt >= MaxAnswerAttempts, not(speechText(S, 1, _)), not(keyListValues(S, [type, response], [mc, touch])), NextAttempt is CurrentAttempt + 1)
			then delete(started, waitingForAnswer, currentAttempt(CurrentAttempt)) + insert(start, currentAttempt(NextAttempt), speechText(S, 1, 'fail')).
		
		%If the number of attempts are not reached, the user will get a next speech recognition attempt.
		if bel(started, CurrentAttempt < MaxAnswerAttempts, not(keyListValues(S, [type, response], [mc, touch])), NextAttempt is CurrentAttempt + 1)
			then delete(started, waitingForAnswer, currentAttempt(CurrentAttempt)) + insert(start, currentAttempt(NextAttempt)).
		%TODO: This needs to be taken outside this loop.
		if bel(keyListValues(S, [type, response], [mc, touch]), mcCounter(C), Cnew is C + 1)
			then delete(waitingForAnswer, mcCounter(C)) + insert(mcCounter(Cnew)).
	}
	
	% If this timer has timed out, and we still have no answer, we need to leave the state, and
	% we insert a fake answer for completion but with a 'fail' condition (substituted for default next condition).
	if bel(currentTopic(Topic), currentState(S), state(Topic, S, question), keyValue(S, context, Context), waitingForAnswer,
		timeout(dialogflow), keyValue(S, maxAnswerAttempts, MaxAnswerAttempts), currentAttempt(CurrentAttempt))
	then {
		if bel(started, CurrentAttempt < MaxAnswerAttempts, not(keyListValues(S, [type, response], [mc, touch])), NextAttempt is CurrentAttempt + 1)
			then delete(started, waitingForAnswer, currentAttempt(CurrentAttempt)) + insert(start, currentAttempt(NextAttempt)).
		if bel(started, CurrentAttempt >= MaxAnswerAttempts, not(keyListValues(S, [type, response], [mc, touch])), nextCondition(C))
			then delete(currentAttempt(CurrentAttempt), waitingForAnswer, nextCondition(C))
			+ insert(currentAttempt(1), answer(S, Context, 'fail', []), nextCondition('fail')) + log(failed(S)).
		
		%TODO: This needs to be taken outside this loop.
		if bel(keyListValues(S, [type, response], [mc, touch]), mcCounter(C), Cnew is C + 1)
			then delete(waitingForAnswer, mcCounter(C)) + insert(mcCounter(Cnew)).
	}
	
	% When timeout occurs while waiting for audio, audio recording is completed, so stop listening (and waiting for audio input). 
	if bel(currentState(S), state(_, S, audioInput), timeout(S), waitingForAudio)
		then stopListening + disableRecording + delete(waitingForAudio).

	% When timeout occurs while waiting for emotion, emotion detection is stopped.
	if bel(currentState(S), state(_, S, emotion), timeout(S), waitingForEmotion, not(emotion(S,_)))
		then stopWatching + insert(emotion(S, 'fail')) + delete(waitingForEmotion).
		
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% Setting things up for input handling %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% Question
	if bel(currentState(S), state(_, S, question), eventsCompleted, currentAttempt(CurrentAttempt), not(waitingForAnswer), not(answer(_, _, _, _)))
	then {
		% Start listening (with timeout by starting timer) and set waitingForAnswer flag.
		% when events have been completed (and we're not already waiting for an answer).
		% the first attempt has a different default waiting time than the subsequent attempts.
		if bel(CurrentAttempt == 1, keyListValues(S, [response, context, maxAnswerTimeFirst], [speech, C, MAX_AT]))
			then startListening(C) + starttimer(S, MAX_AT, MAX_AT) + insert(waitingForAnswer).
		% answer time for second (and more; depends on maxAnswerAttempt) speech attempts.
		if bel(CurrentAttempt > 1, keyListValues(S, [response, context, maxAnswerTimeSecond], [speech, C, MAX_AT]))
			then startListening(C) + starttimer(S, MAX_AT, MAX_AT) + insert(waitingForAnswer).
		
		% Start timer for question state with touch response and set waitingForAnswer flag.
		% when events have been completed (and we're not already waiting for an answer).
		if bel(keyListValues(S, [type, response, maxAnswerTimeTouch], [yesno, touch, MAX_AT]))
		then starttimer(S,MAX_AT,MAX_AT) + insert(waitingForAnswer).
		
		% Cycle through multiple choice options, start timer for question state with touch response and set waitingForAnswer flag.
		% when events have been completed (and we're not already waiting for an answer).
		if bel(keyListValues(S, [type, response, maxAnswerTimeTouch, options], [mc, touch, MAX_AT, Values]),
			mcCounter(C), nth0(C, Values, Value), atom_string(Value, String))
		then say(String) + starttimer(S,MAX_AT,MAX_AT) + insert(waitingForAnswer).
	}
	
	% Audiorecording
	if bel(currentState(S), state(_, S, audioInput), not(waitingForAudio), not(audioRecording(S,_)),
		keyListValues(S, [recordTime], [RT]))
		then enableRecording + startListening + starttimer(S, RT, RT) + insert(waitingForAudio).
	
	% Emotion
	if bel(currentState(S), state(_, S, emotion), not(waitingForEmotion), not(emotion(S,_)))
		then startWatching + starttimer(S, 6000, 6000) + insert(waitingForEmotion).

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%% State transition handling            %%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% If state has been completed,  
	if bel(currentTopic(T), completed(S), nextCondition(C))
	then { % ... clean up (and reset nextCondition to default value 'true') ...
		% Cleanup: remove all answers (if any).
		forall bel(answer(S, Context, I, Params)) do delete(answer(S, Context, I, Params)).
		% Cleanup: remove state specific parameters (if any).
		if bel(keyValue(S, options, _), mcCounter(C)) then delete(mcCounter(C)).
		% Cleanup: Remove current, completed state and reset state tracking parameters to their default values.
		if bel(currentAttempt(Attempt))
			then delete(currentState(S), started, nextCondition(C), currentAttempt(Attempt))
				+ insert(start, nextCondition('true'), currentAttempt(1)).

		% ... and transition to next state (if there is one) ...
		if bel(next(T, S, C, Snext))
			then insert(currentState(Snext)). % Progress: move to next state
			
		% ... or go to next topic if a topic has been completed (no next state has been specified for the topic).
		if goal(topics(AllTopics)), not(bel(next(T, S, C, _)))
		then {
			if bel(topics(TopicsDone), append(TopicsDone, [T], NewTopicsDone))
				then delete(topics(TopicsDone)) + insert(topics(NewTopicsDone)).
			% get new topic (if any is left).
			if bel(topics(TopicsDone), append(TopicsDone, [H | _], AllTopics))
				then delete(currentTopic(T)) + insert(currentTopic(H), currentState(s1)).
		}
				
		% And, finally, initialize state specific parameters for new state (if any).
		if bel(currentState(Snow), keyValue(Snow, options, _)) then insert(mcCounter(0)).
	}
}